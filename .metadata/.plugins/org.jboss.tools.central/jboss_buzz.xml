<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" media="screen" href="/~d/styles/atom10full.xsl"?><?xml-stylesheet type="text/css" media="screen" href="http://feeds.feedburner.com/~d/styles/itemcontent.css"?><feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><title>JBoss Tools Aggregated Feed</title><link rel="alternate" href="http://tools.jboss.org" /><subtitle>JBoss Tools Aggregated Feed</subtitle><dc:creator>JBoss Tools</dc:creator><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="self" type="application/atom+xml" href="http://feeds.feedburner.com/jbossbuzz" /><feedburner:info xmlns:feedburner="http://rssnamespace.org/feedburner/ext/1.0" uri="jbossbuzz" /><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="hub" href="http://pubsubhubbub.appspot.com/" /><entry><title>Quarkus Newsletter #18 - March</title><link rel="alternate" href="&#xA;                https://quarkus.io/blog/quarkus-newsletter-18/&#xA;            " /><author><name>James Cobb (https://twitter.com/insectengine)</name></author><id>https://quarkus.io/blog/quarkus-newsletter-18/</id><updated>2022-03-17T00:00:00Z</updated><published>2022-03-17T00:00:00Z</published><summary type="html">The March newsletter has been sent. Learn about what’s new with Java 17 and containers, read about LogicDrop and Vaadin’s path to using Quarkus, and get a look at Continuous testing with Quarkus. Additionally, you’ll get more insights into how Keycloak is ow fully cloud-native with Quarkus and learn how...</summary><dc:creator>James Cobb (https://twitter.com/insectengine)</dc:creator><dc:date>2022-03-17T00:00:00Z</dc:date></entry><entry><title>Choose the best camel for your integration ride, Part 3</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/03/16/choose-best-camel-your-integration-ride-part-3" /><author><name>Bruno Meseguer</name></author><id>977c5163-86f5-42a5-903e-4ff5178d206a</id><updated>2022-03-16T07:00:00Z</updated><published>2022-03-16T07:00:00Z</published><summary type="html">&lt;p&gt;The previous installments in this series &lt;a href="https://developers.redhat.com/articles/2022/01/26/choose-best-camel-your-integration-ride-part-1"&gt;explored the motivations behind different community-supported runtimes&lt;/a&gt; for &lt;a href="https://camel.apache.org"&gt;Apache Camel&lt;/a&gt; and &lt;a href="https://developers.redhat.com/articles/2022/01/26/choosing-best-camel-your-integration-ride-part-2"&gt;enumerated in detail the benefits of each runtime&lt;/a&gt;. This final installment gives you a simplified and opinionated decision flow containing basic questions to help you identify which Camel runtime will work best for you.&lt;/p&gt; &lt;p&gt;The obvious first question is what happens if your organization mandates all aspects of the development process, including the technologies and runtimes to use. If that's the case, the guidance in this series of articles would appear of no use. You can, however, suggest what in your view could be a positive change to their current choices.&lt;/p&gt; &lt;h2&gt;Choose the right Camel runtime for your environment&lt;/h2&gt; &lt;p&gt;The decision tree in Figure 1 tries to recommend the best Camel runtime for you, depending on your target environment.&lt;/p&gt; &lt;p&gt;The major division in Figure 1 is between &lt;a href="https://developers.redhat.com/topics/containers"&gt;containerized&lt;/a&gt; and non-containerized environments. The first part of this series described the evolution of integration applications and how the emergence of containers accelerated the shift to &lt;a href="https://developers.redhat.com/topics/microservices"&gt;microservice architectures&lt;/a&gt;. This transition does not necessarily mean that all integration projects must become microservices running in containers. The trend just added new miles to our road—that is, new places to survey during your decision-making.&lt;/p&gt; &lt;p&gt;It's up to you whether or not to embrace &lt;a href="https://developers.redhat.com/topics/kubernetes"&gt;Kubernetes&lt;/a&gt;, depending on your requirements and budget. If you don't, remember Kubernetes as a possible target environment. I's also wise to keep Kubernetes in mind in case plans come up in your organization to transition to containers and microservices.&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content-full-width"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/decision-diagram.jpg" data-featherlight="image"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/styles/article_full_width_1440px_w/public/decision-diagram.jpg?itok=cQNFvd-t" width="1440" height="829" alt="Containers, complexity, and developer control are the main factors determining the best runtime for Apache Camel." loading="lazy" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 1: Containers, complexity, and developer control are the main factors determining the best runtime for Apache Camel. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;h2&gt;Camel for standalone applications&lt;/h2&gt; &lt;p&gt;For many developers, running integrations in a Kubernetes environment is not an option or is simply overkill. In that case, choose a standalone Camel runtime.&lt;/p&gt; &lt;p&gt;If you'll be running standalone, and you're not planning to implement many services, consider adopting Camel Quarkus for its simplicity, performance, super low memory footprint, and compatibility with Camel 3.&lt;/p&gt; &lt;p&gt;Another good reason to prefer Camel Quarkus over other standalone runtimes is that it represents the future of Camel, where the community invests most of its effort. You should also consider that while today you may be running just in standalone mode, Camel Quarkus leaves an open door to comfortably transition to container environments when the opportunity arises.&lt;/p&gt; &lt;p&gt;However, if you foresee the need to implement extra services, consider bundling your application in a fully featured OSGi container such as Karaf. Try to ensure that you keep your Camel projects small and independent, avoiding monolithic structures that are challenging to evolve; OSGI's architecture should help you with that.&lt;/p&gt; &lt;h2&gt;Camel for Kubernetes&lt;/h2&gt; &lt;p&gt;Let's look at your options If your target environment is Kubernetes. Because containers favor distributed architectures and encourage splitting big application servers into independent microservices, deploying OSGi engines in containers doesn't make much sense. Running one service per container is the best practice.&lt;/p&gt; &lt;p&gt;To fit the slim image sizes desired for containers and Kubernetes, many developers feel tempted to switch from Java to other languages that provide a lighter and smaller runtime. The downside is that most of these languages lack the maturity of Java, and more importantly, the rich connectivity and functionality specifically designed to solve &lt;a href="https://camel.apache.org/components/next/eips/enterprise-integration-patterns.html"&gt;enterprise integration patterns&lt;/a&gt; that Camel brings.&lt;/p&gt; &lt;p&gt;Up until now, the most popular runtime to deploy Camel in Kubernetes was Spring Boot, which seemed to be a lightweight alternative to existing Java frameworks when it was introduced but now appears relatively heavyweight. Now Quarkus is on the scene to provide supersonic, subatomic Java. Quarkus promises a long life for Camel in the container space, to the delight of many developers already using Java and Camel.&lt;/p&gt; &lt;p&gt;Camel Quarkus provides very economical memory usage and top performance. Thus, Camel Quarkus meets the requirements of serverless platforms, where applications scale to zero when idle and react to incoming traffic by waking up and responding in just a few milliseconds. This behavior, of course, has tremendous benefits in the use of platform resources.&lt;/p&gt; &lt;p&gt;For the reasons cited here, the diagram includes Camel Quarkus and Camel K (Quarkus based) only. We have discarded other non-Quarkus Java runtimes for missing out on those characteristics.  In conclusion, it is a matter of choosing between the two. &lt;/p&gt; &lt;h2&gt;Trading off simplicity and control&lt;/h2&gt; &lt;p&gt;Suppose there are considerable data transformations to be defined and nontrivial processing logic in your service: for instance, interacting with multiple endpoints. In that case, you should retain maximum control of Camel's framework. That's what Camel Quarkus provides and what the traditional Camel developer is used to, except with the much-improved performance that Quarkus achieves. As an analogy, imagine you have complete design control over the electronics that power a multicolor LED bulb (Figure 2).&lt;/p&gt; &lt;figure class="rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content-full-width"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/bulb-circuit_0.gif"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/bulb-circuit_0.gif" width="753" height="398" alt="Quarkus can be imagined as giving you full control over the electronics of a multicolor LED bulb." loading="lazy" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 2: Quarkus can be imagined as giving you full control over the electronics of a multicolor LED bulb.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;However, with today's explosion of data flows, very often, use cases are relatively simple. Developers generally seek to fetch data from data sources or feed data to target platforms, with relatively low data handling or none at all.&lt;/p&gt; &lt;p&gt;That's Camel K's sweet spot. It delivers super connectivity with Camel's rich palette of connectors and can still include a reasonable degree of data manipulation if desired; however, as a basic principle, you should try to keep service options for each application to a minimum. Back to our bulb example, imagine you can turn the light on and off with a knob that controls its intensity (Figure 3).&lt;/p&gt; &lt;figure class="rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content-full-width"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/bulb-dimmer_0.gif"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/bulb-dimmer_0.gif" width="600" height="364" alt="Camel K is comparable to a dimmer switch that controls light intensity." loading="lazy" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 3: Camel K is comparable to a dimmer switch that controls light intensity.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Of course, the animation in Figure 3 just illustrates the concept. Still, it might help you visualize how Camel K hides much of the complexity from you, in contrast with the fully designed electronics of the multicolor bulb where full attention to all details is necessary.&lt;/p&gt; &lt;p&gt;Camel K's &lt;a href="https://camel.apache.org/manual/dsl.html"&gt;Domain Specific Language (DSL)&lt;/a&gt; is an excellent choice for simple use cases. The DSL offers some degree of control (the knob controlling light intensity), simplifying the developer's work and letting the Operator manage the service's lifecycle.&lt;/p&gt; &lt;p&gt;To better grasp what a simple use case could look like and the power that Camel K can deliver, check &lt;a href="https://developers.redhat.com/articles/2021/11/24/normalize-web-services-camel-k-and-atlasmap-part-1"&gt;this two-part series&lt;/a&gt; detailing a complete API integration. Following best practices, the example in that series exposes an OpenAPI service, applies data transformation, connects to an endpoint, and processes its response.&lt;/p&gt; &lt;h3&gt;Kamelet bindings&lt;/h3&gt; &lt;p&gt;The last decision in our diagram separates Camel K's traditional developer's style from the "no-code" style of using Kamelet bindings, as introduced in &lt;a href="https://developers.redhat.com/articles/2022/01/26/choosing-best-camel-your-integration-ride-part-2#camel_spring_boot"&gt;Part 2 of this series&lt;/a&gt;. The Kamelet binding construct is meant for an even higher level of abstraction, allowing for configuration-only use cases. The Kamelet binding uses pre-built, out-of-the-box Kamelets. Think of these as processing flows you enable and disable, but to which you don't apply much further control. Again, back to our bulb example, imagine we're turning the light on and off using a switch.&lt;/p&gt; &lt;figure class="rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content-full-width"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/bulb-switch_1.gif"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/bulb-switch_1.gif" width="600" height="365" alt="Kamelets are comparable to a switch that turns the light on and off." loading="lazy" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 4: Kamelets are comparable to a switch that turns the light on and off.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;When you push a Kamelet binding, it's as if you press the switch to turn the light on. The Operator reads its definition and deploys an integration process that executes it. If you later delete the Kamelet binding resource, the Operator stops it and tears it down, as if switching the light off.&lt;/p&gt; &lt;p&gt;For more formal examples, look at &lt;a href="https://developers.redhat.com/articles/2021/09/14/improve-cross-team-collaboration-camel-k"&gt;this article&lt;/a&gt; that explains the use of both the DSL and Kamelet bindings. If you look at steps 1 and 3 of the article, in particular, you'll see how the configuration-only blocks enable integration stages of the end-to-end data flow.&lt;/p&gt; &lt;p&gt;Although Kamelet bindings can seem very restrictive, if you'd like a bit more control, you can define new Kamelets in your catalog to satisfy your requirements. In our metaphor, you can unscrew the light switch and tune it to your liking.&lt;/p&gt; &lt;h2&gt;Final words&lt;/h2&gt; &lt;p&gt;Apache Camel is known as the Swiss knife of integration, and you probably grasped by now that Camel goes even further than that. It offers a wide variety of different runtimes that help propagate a solid foundation for integrations.&lt;/p&gt; &lt;p&gt;It's helpful to understand Camel's timeline and how it has evolved, continuously looking at new horizons. You can then find out which Camel runtime fits better in your world and take advantage.&lt;/p&gt; &lt;p&gt;You can undoubtedly integrate systems with arbitrary languages and frameworks, but that's like random shooting from recoil. Apache Camel is like harnessing standard light energy to provide you with a sharp laser-pointing focus.&lt;/p&gt; &lt;h2 id="learn_more_about_camel_k-h2"&gt;Learn more about Camel Quarkus and Camel K&lt;/h2&gt; &lt;p&gt;See the following resources to learn more about Camel Quarkus and Camel K:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Explore in more detail Camel Quarkus by reading &lt;a href="https://developers.redhat.com/articles/2021/12/06/boost-apache-camel-performance-quarkus"&gt;Boost Apache Camel performance with Quarkus&lt;/a&gt;.&lt;/li&gt; &lt;li&gt;Read the article &lt;a href="https://developers.redhat.com/articles/2021/09/14/improve-cross-team-collaboration-camel-k"&gt;Improve cross-team collaboration with Camel K&lt;/a&gt; to learn about Kamelet bindings and the DSL.&lt;/li&gt; &lt;li&gt;Learn how to implement a complete API integration using &lt;a href="https://developers.redhat.com/articles/2021/11/24/normalize-web-services-camel-k-and-atlasmap-part-1"&gt;Camel K and AtlasMap&lt;/a&gt;.&lt;/li&gt; &lt;li&gt;A good place to start learning about Camel K is the &lt;a href="https://developers.redhat.com/topics/camel-k"&gt;Camel K topic page&lt;/a&gt; on Red Hat Developer.&lt;/li&gt; &lt;li&gt;Visit the &lt;a href="https://developers.redhat.com/products/integration/overview"&gt;Red Hat Integration&lt;/a&gt; page on developers.redhat.com to see complementary capabilities around Camel.&lt;/li&gt; &lt;/ul&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/03/16/choose-best-camel-your-integration-ride-part-3" title="Choose the best camel for your integration ride, Part 3"&gt;Choose the best camel for your integration ride, Part 3&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Bruno Meseguer</dc:creator><dc:date>2022-03-16T07:00:00Z</dc:date></entry><entry><title>Quarkus 2.7.5.Final released - Maintenance release</title><link rel="alternate" href="&#xA;                https://quarkus.io/blog/quarkus-2-7-5-final-released/&#xA;            " /><author><name>Guillaume Smet (https://twitter.com/gsmet_)</name></author><id>https://quarkus.io/blog/quarkus-2-7-5-final-released/</id><updated>2022-03-16T00:00:00Z</updated><published>2022-03-16T00:00:00Z</published><summary type="html">Today, we released 2.7.5.Final which, as usual, only contains bugfixes and documentation improvements. It is a safe upgrade for anyone already using 2.7. If you are not using 2.7 already, please refer to the 2.7 migration guide. Full changelog You can get the full changelog of 2.7.5.Final on GitHub. Come...</summary><dc:creator>Guillaume Smet (https://twitter.com/gsmet_)</dc:creator><dc:date>2022-03-16T00:00:00Z</dc:date></entry><entry><title>Preview: Clustering support for JBoss EAP on Azure App Service</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/03/15/preview-clustering-support-jboss-eap-azure-app-service" /><author><name>James Falkner</name></author><id>0cc45e22-c39c-4482-9d0e-f05a67374419</id><updated>2022-03-15T08:00:00Z</updated><published>2022-03-15T08:00:00Z</published><summary type="html">&lt;p&gt;Clustering support for &lt;a href="https://developers.redhat.com/products/eap/overview"&gt;Red Hat JBoss Enterprise Application Platform&lt;/a&gt; (JBoss EAP) on &lt;a href="https://azure.microsoft.com/en-us/services/app-service/"&gt;Azure App Service&lt;/a&gt; is now available in &lt;a href="https://techcommunity.microsoft.com/t5/apps-on-azure-blog/clustering-support-for-jboss-eap-on-azure-app-service-public/ba-p/3252898"&gt;public preview&lt;/a&gt;. JBoss EAP &lt;a href="https://www.redhat.com/en/about/press-releases/red-hat-brings-jboss-enterprise-application-platform-microsoft-azure-easing-shift-cloud-traditional-java-applications"&gt;has been available&lt;/a&gt; as a supported runtime on both Azure virtual machines (via the &lt;a href="https://azuremarketplace.microsoft.com/en-us/marketplace/apps/redhat.jboss-eap-rhel"&gt;Azure Marketplace&lt;/a&gt;) and &lt;a href="https://azure.microsoft.com/en-us/blog/deploy-apps-seamlessly-with-red-hat-jboss-eap-on-azure-app-service-now-generally-available/"&gt;Azure App Service&lt;/a&gt; since June 2021.&lt;/p&gt; &lt;p&gt;If you're looking to move your Jakarta Enterprise Edition (Jakarta EE) applications to the cloud, you can use these offerings to maintain your investment in Jakarta EE and JBoss EAP while benefiting from the depth and breadth of the Microsoft Azure platform and related services.&lt;/p&gt; &lt;h2&gt;Benefits of clustering on Azure App Service&lt;/h2&gt; &lt;p&gt;JBoss EAP clustering enables distributed applications to share data seamlessly and improve resistance to fluctuations in data flow and server load, as well as server failure. Although clustering has been supported on Azure VMs for many years, it required &lt;a href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.4/html-single/using_jboss_eap_in_microsoft_azure/index#using_jboss_eap_high_availability_in_microsoft_azure"&gt;careful configuration&lt;/a&gt; of JBoss EAP, including networking (e.g., multicast or the use of the &lt;code&gt;AZURE_PING&lt;/code&gt; protocol), load balancing, failover configuration, and more.&lt;/p&gt; &lt;p&gt;With JBoss EAP on Azure App Service, once added to an Azure Virtual Network (VNet), JBoss EAP will automatically start as a clustered service, using virtual networking for node-to-node communication. It will also be enabled for scaling operations (scaling up or down as desired, based on scale configuration) through Azure App Service. The benefits are summarized in the following video.&lt;/p&gt; &lt;div class="video-embed-field-provider-youtube video-embed-field-responsive-video"&gt; &lt;/div&gt; &lt;p&gt;In addition to clustering of JBoss EAP, Azure App Service offers a wide range of capabilities, including developer tooling, advanced deployment options, integration with Azure Application Insights and Azure Monitor, network isolation options, and multiple pricing tiers. JBoss EAP on Azure App Service is fully supported with integrated support from Microsoft and Red Hat. The combination of JBoss EAP, a leading Jakarta EE platform, with Microsoft Azure, a leading cloud platform, gives JBoss EAP users a powerful path to the cloud.&lt;/p&gt; &lt;p&gt;For more detail around this public preview of JBoss EAP clustering support on Azure App Service, read &lt;a href="https://techcommunity.microsoft.com/t5/apps-on-azure-blog/clustering-support-for-jboss-eap-on-azure-app-service-public/ba-p/3252898"&gt;Microsoft's blog post announcement&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;How to get started&lt;/h2&gt; &lt;p&gt;If you want to try out the public preview today, get started with this 7-minute &lt;a href="https://github.com/Azure-Samples/clustered-jboss-demo"&gt;Clustered JBoss EAP on Azure App Service quickstart&lt;/a&gt;. This sample deploys a representative distributed application to JBoss EAP on Azure App Service, showing how clustering works.&lt;/p&gt; &lt;h2&gt;Additional resources&lt;/h2&gt; &lt;p&gt;More details and documentation are available at the following sites:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;&lt;a href="https://www.redhat.com/en/technologies/jboss-middleware/application-platform/azure"&gt;Red Hat JBoss EAP on Azure App Service data sheet and checklist&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.4/html/configuration_guide/configuring_high_availability"&gt;Red Hat JBoss EAP documentation on high availability&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://www.redhat.com/en/about/press-releases/red-hat-brings-jboss-enterprise-application-platform-microsoft-azure-easing-shift-cloud-traditional-java-applications"&gt;Press release about JBoss EAP on Azure&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=XA9QELCmGZE"&gt;JBoss EAP on Azure App Service introduction video&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/03/15/preview-clustering-support-jboss-eap-azure-app-service" title="Preview: Clustering support for JBoss EAP on Azure App Service"&gt;Preview: Clustering support for JBoss EAP on Azure App Service&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>James Falkner</dc:creator><dc:date>2022-03-15T08:00:00Z</dc:date></entry><entry><title>Choose the best camel for your integration ride, Part 2</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/03/15/choose-best-camel-your-integration-ride-part-2" /><author><name>Bruno Meseguer</name></author><id>32e1989e-8139-4ee6-83ec-0797ae31d009</id><updated>2022-03-15T07:00:00Z</updated><published>2022-03-15T07:00:00Z</published><summary type="html">&lt;p&gt;This article is the second installment of a series that helps you choose among the many open source integration runtime provided by the &lt;a href="https://camel.apache.org"&gt;Apache Camel&lt;/a&gt; framework. &lt;a href="https://developers.redhat.com/articles/2022/01/26/choose-best-camel-your-integration-ride-part-1"&gt;Part 1 of the series&lt;/a&gt; introduced the landscape of Camel runtime options and explained the use case and historical needs addressed by each runtime. This article expands on the advantages and recommended uses for the main runtimes currently supported by the Apache Camel project: &lt;a href="https://camel.apache.org/camel-karaf/next/index.html"&gt;Apache Karaf&lt;/a&gt; (&lt;a href="https://www.osgi.org/"&gt;OSGi&lt;/a&gt;), &lt;a href="https://camel.apache.org/camel-spring-boot/next/index.html"&gt;Spring Boot&lt;/a&gt;, &lt;a href="https://camel.apache.org/camel-quarkus/next/index.html"&gt;Quarkus&lt;/a&gt;, and &lt;a href="https://developers.redhat.com/topics/camel-k"&gt;Camel K&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Camel's light footprint and versatility also allow for other types of deployment. For instance, you might embed Camel directly as a library to empower your existing application with integration abilities. Or, for similar reasons, you might deploy Camel in an existing web container.&lt;/p&gt; &lt;p&gt;This series doesn't intend to enumerate all the available Camel permutations. We're simply covering the most common community-supported runtimes to run Camel in the enterprise, whether standalone or using a containerized environment such as &lt;a href="https://developers.redhat.com/topics/kubernetes"&gt;Kubernetes&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;Camel Karaf (OSGi)&lt;/h2&gt; &lt;p&gt;From a technical viewpoint, to gain unlimited access to the full power of Camel to tackle all use cases, from the most basic to the most challenging ones, Karaf is the more capable of all the Camel runtimes. The core ability of Karaf's underlying standard, OSGi, is to host many independent modules (bundles), each one loaded by its privately assigned class loader, which allows you to run multiple Camel projects simultaneously. The comprehensiveness of the OSGi solution allows numerous &lt;code&gt;CamelContext&lt;/code&gt; instances to coexist under the same JVM and to communicate with one another.&lt;/p&gt; &lt;p&gt;If you want maximum control and intend to implement many services, OSGI seems like the right choice. It's important to note, though, that exploiting OSGi's special powers might create difficulties if down the line you plan to transition to containers. On the one hand, OSGi encourages you to modularize your services well, which helps you adopt a &lt;a href="https://developers.redhat.com/topics/microservices"&gt;microservices&lt;/a&gt; mindset. But if you're not cautious, you might lock yourself into the technology.&lt;/p&gt; &lt;h2&gt;Camel Spring Boot&lt;/h2&gt; &lt;p&gt;OSGi proved to be overwhelming for many developers, especially inexperienced ones, who prefer simple runtimes where only a single service (&lt;code&gt;CamelContext&lt;/code&gt;) runs. These developers gravitated to Camel in Spring Boot, which sacrifices the ability to bundle multiple services together, but still tapped into most of Camel's flexibility and functionality and provided much simpler dependency management.&lt;/p&gt; &lt;p&gt;Spring Boot offers advantages, among other areas, in easier development, autoconfiguration, and more straightforward setup and management, all significantly contributing to its popularity.&lt;/p&gt; &lt;p&gt;Camel on Spring boot has become the most attractive option when deploying in container environments because of its one-Camel-per-instance simplicity. However, as pointed out in Part 1 of this series, running many Spring Boot microservices becomes expensive; its footprint is too big in comparison with non-Java runtimes that are better adapted to the needs of container environments.&lt;/p&gt; &lt;h2&gt;Camel Quarkus&lt;/h2&gt; &lt;p&gt;Camel Quarkus is the latest Camel runtime generation. It allows you to run integration processes with super low memory usage, fast startup, and outstanding performance. The article &lt;a href="https://developers.redhat.com/articles/2021/12/06/boost-apache-camel-performance-quarkus"&gt;Boost Apache Camel performance on Quarkus&lt;/a&gt; introduces the topic well.&lt;/p&gt; &lt;p&gt;Like Spring Boot, &lt;a href="https://developers.redhat.com/products/quarkus/overview"&gt;Quarkus&lt;/a&gt; runs a single &lt;code&gt;CamelContext&lt;/code&gt; runtime. Although Quarkus doesn't provide you with the unique characteristics that OSGi offers to contain many Camel instances, Quarkus runs standalone both outside and inside containers.&lt;/p&gt; &lt;p&gt;Camel Quarkus requires the latest version of Camel (version 3), whose use is encouraged for all Camel users anyway. If you happen to depend on Camel 2, you'll have to choose a different runtime and forego Quarkus's compactness.&lt;/p&gt; &lt;p&gt;Camel Quarkus is also the base runtime for Camel K, which I'll explain in detail in the following section.&lt;/p&gt; &lt;h2&gt;Camel K: Operator-based Camel&lt;/h2&gt; &lt;p&gt;With generic Camel and Camel Quarkus, developers have complete framework control at their disposal. In more specific terms, the developer has full access to the &lt;code&gt;CamelContext&lt;/code&gt; and can, for instance, wire in Java beans and use them in Camel routes. In other words, the developer rides the Camel.&lt;/p&gt; &lt;p&gt;In contrast, with Camel K, the Operator takes the reins (Figure 1). Camel K introduces abstraction layers to make Camel easier for the end-user and consequently needs to take over some control from the developer. It's a compromise you could accept to enjoy a more user-friendly experience.&lt;/p&gt; &lt;figure class="rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/robo-camel.jpeg" data-featherlight="image"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/robo-camel.jpeg?itok=A-hVWdwn" width="600" height="415" alt="Depiction of a robotic camel. " loading="lazy" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 1: Operator-based Camel. "&lt;a href="https://mir-s3-cdn-cf.behance.net/project_modules/fs/96f92329148405.55e4e447c426d.jpg"&gt;Camel&lt;/a&gt;" by "&lt;a href="https://www.behance.net/zeppelinstudios"&gt;Zeppelin Creative Studio&lt;/a&gt;" under &lt;a href="https://creativecommons.org/licenses/by-nc/4.0/deed.en_US"&gt;CC BY-NC 4.0&lt;/a&gt; / Modified from original.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;The following subsections describe three levels of abstraction that you can achieve using Camel K.&lt;/p&gt; &lt;h3&gt;Abstraction 1: Improved developer experience&lt;/h3&gt; &lt;p&gt;To start with, Camel K encourages you to create a single file to implement your Camel routes. You might have to include extra resource files (typically to help configure your endpoints), but that's about it: No project trees, no dependency descriptors (e.g., POM files in Maven).&lt;/p&gt; &lt;p&gt;The sweet spot of Camel K is connectivity or event-driven use cases, from source to target, where process/data mediation may be necessary. If you find that your use case requires higher complexity, perhaps with more than one or two target endpoints, Camel K may still be suitable, but probably you should rely on traditional Camel using Quarkus.&lt;/p&gt; &lt;h3&gt;Abstraction 2: Kamelets&lt;/h3&gt; &lt;p&gt;A second abstraction layer, introduced by Camel K, involves Kamelets, which are essentially predefined route snippets. A Kamelet typically uses a Camel connector (component) with additional logic. By enriching standard Camel connectors, Kamelets effectively become "intelligent connectors" convenient to have as reusable building blocks that you can invoke in a single line from your Camel code.&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;img alt="Figure 2: Kamelet plugs into standard Camel component." data-entity-type="file" data-entity-uuid="82bf508b-0556-4c19-b240-7fa45f24c561" height="353" src="https://developers.redhat.com/sites/default/files/inline-images/concept-kamelet_0.jpg" width="365" loading="lazy" /&gt;&lt;figcaption class="rhd-c-caption"&gt;Figure 2: Kamelet plugs into standard Camel component.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Figure 2 portrays a Kamelet metaphorically as a smart encapsulated device that plugs by default into a network socket, that is, the standard Camel component from where the data originates. Think of the pluggable device as a preprogrammed connector with added intelligence.&lt;/p&gt; &lt;p&gt;Camel K provides a whole collection of Kamelets out of the box. You can browse its &lt;a href="https://camel.apache.org/camel-kamelets/0.6.x/index.html"&gt;catalog&lt;/a&gt; and pick the Kamelet that fits your use case. A valuable benefit to consider is that you can also create your own Kamelets, customized to your team's needs, effectively composing a catalog for your organization.&lt;/p&gt; &lt;p&gt;Kamelets are great to use as generic sources and sinks (illustrated in Figure 3) and are also ideal building blocks for low-code and no-code web and graphical user interfaces. Because of Kamelets' atomic encapsulation, you can just specify some parameters in their environment to configure them. The pluggable aspect of Kamlets enables the next abstraction level in Camel.&lt;/p&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;img alt="Figure 3: Catalogue of source and sink Kamelets." data-entity-type="file" data-entity-uuid="07368ead-f73c-48b6-b4e7-c0061fb3e3bc" height="333" src="https://developers.redhat.com/sites/default/files/inline-images/concept-kamelet-catalog_0.jpg" width="850" loading="lazy" /&gt;&lt;figcaption class="rhd-c-caption"&gt;Figure 3: Catalogue of source and sink Kamelets.&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;Abstraction 3: Kamelet bindings&lt;/h3&gt; &lt;p&gt;A third abstraction layer consists of Kamelet bindings. As the name suggests, Camel K allows you to plug Kamelets together, typically a source and a sink, to form a processing chain that enables an integration data flow between a source system and a target system (see Figure 4).&lt;/p&gt; &lt;figure class="rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content-full-width"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/concept-kamelet-bindings_2.gif"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/concept-kamelet-bindings_2.gif" width="639" height="345" alt="Figure 4: Kamelet binding enabling a data flow." loading="lazy" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 4: Kamelet binding enabling a data flow.&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;You could implement the same processing flow with plain Camel code, but the power of Kamelet bindings lies in relieving you from coding the flows; you're only selecting and configuring reusable components. Kamelet bindings translate into deployed executable instances that Camel K operates, whereas Kamelets are passive entities in a catalog.&lt;/p&gt; &lt;p&gt;Because Kamelets represent reusable connectors requiring just configuration, Kamelet bindings are inherently no-code definitions (in YAML) with just input parameters. It's easy for anyone with access to an environment powered by Camel K to quickly compose a Kamelet binding by pairing a source Kamelet with a sink Kamelet and populating their parameters. The Operator will ride the Camel and deploy a running instance that complies with your definition.&lt;/p&gt; &lt;p&gt;For example, imagine that you pick the Twitter source Kamelet and the Kafka sink Kamelet from the catalog and bind them together (Figure 5). The moment you push its YAML definition to Kubernetes, the Camel K Operator reacts by deploying an integration process that goes live. A data stream of tweets starts flowing from Twitter to Kafka.&lt;/p&gt; &lt;figure class="rhd-u-has-filter-caption" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content-full-width"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/concept-kamelet-binding.gif"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/concept-kamelet-binding.gif" width="600" height="287" alt="Figure 5: Twitter source binding to Kafka sink." loading="lazy" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 5: Twitter source binding to Kafka sink.&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;Up next&lt;/h2&gt; &lt;p&gt;This article covered the main advantages of the major runtimes currently supported by open source communities, as well as comprehensive information on the most innovative runtime, Camel K.&lt;/p&gt; &lt;p&gt;&lt;a href="https://developers.redhat.com/articles/2022/03/16/choose-best-camel-your-integration-ride-part-3"&gt;The final installment in this series&lt;/a&gt; will offer a quick guide to help you organize your criteria and choose the best Camel to ride.&lt;/p&gt; &lt;h2 id="learn_more_about_camel_k-h2"&gt;Learn more about Camel Quarkus and Camel K&lt;/h2&gt; &lt;p&gt;See the following resources to learn more about Camel Quarkus and Camel K:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Explore in more detail Camel Quarkus by reading &lt;a href="https://developers.redhat.com/articles/2021/12/06/boost-apache-camel-performance-quarkus"&gt;Boost Apache Camel performance with Quarkus&lt;/a&gt;.&lt;/li&gt; &lt;li&gt;Read the article &lt;a href="https://developers.redhat.com/articles/2021/09/14/improve-cross-team-collaboration-camel-k"&gt;Improve cross-team collaboration with Camel K&lt;/a&gt; to learn about Kamelet bindings and the DSL.&lt;/li&gt; &lt;li&gt;Learn how to implement a complete API integration using &lt;a href="https://developers.redhat.com/articles/2021/11/24/normalize-web-services-camel-k-and-atlasmap-part-1"&gt;Camel K and AtlasMap&lt;/a&gt;.&lt;/li&gt; &lt;li&gt;A good place to start learning about Camel K is the &lt;a href="https://developers.redhat.com/topics/camel-k"&gt;Camel K topic page&lt;/a&gt; on Red Hat Developer.&lt;/li&gt; &lt;li&gt;Visit the &lt;a href="https://developers.redhat.com/products/integration/overview"&gt;Red Hat Integration&lt;/a&gt; page on developers.redhat.com to see complementary capabilities around Camel.&lt;/li&gt; &lt;/ul&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/03/15/choose-best-camel-your-integration-ride-part-2" title="Choose the best camel for your integration ride, Part 2"&gt;Choose the best camel for your integration ride, Part 2&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Bruno Meseguer</dc:creator><dc:date>2022-03-15T07:00:00Z</dc:date></entry><entry><title type="html">Quarkus Reactive messaging with Kafka</title><link rel="alternate" href="http://www.mastertheboss.com/soa-cloud/quarkus/quarkus-reactive-messaging-with-kafka/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/soa-cloud/quarkus/quarkus-reactive-messaging-with-kafka/</id><updated>2022-03-14T09:36:32Z</updated><content type="html">In this article, we will learn how to create a Quarkus Reactive application which uses the SmallRye Reactive Messaging and Mutiny project to stream data from and to a Kafka cluster. Reactive messaging in a nutshell The architecture style of enterprise application has been changing in the last years. Besides the standard client-server approach we ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title>Choose the best Camel for your integration ride, Part 1</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/03/14/choose-best-camel-your-integration-ride-part-1" /><author><name>Bruno Meseguer</name></author><id>185cd02d-4d47-42d1-9283-9212c93d87de</id><updated>2022-03-14T07:00:00Z</updated><published>2022-03-14T07:00:00Z</published><summary type="html">&lt;p&gt;&lt;a href="https://camel.apache.org"&gt;Apache Camel&lt;/a&gt; is the most popular open source integration framework today. Over the years, Camel has evolved to support new environments such as &lt;a href="https://developers.redhat.com/topics/containers"&gt;containers&lt;/a&gt; on &lt;a href="https://developers.redhat.com/topics/kubernetes"&gt;Kubernetes&lt;/a&gt; while continuously improving the developer experience—so much so that it's now easy to consume by Kubernetes users with no previous Camel experience.&lt;/p&gt; &lt;p&gt;This article, the first in a three-part series, introduces the most important ways you can use Camel and why each came into being. We'll weigh factors such as performance, developer control, environment, and usability to help you understand and select the best flavor of Camel to implement your integration service.&lt;/p&gt; &lt;h2&gt;Integration frameworks&lt;/h2&gt; &lt;p&gt;Integration frameworks address the increasing needs of applications to work with a variety of outside services: databases, message brokers, etc. In the past, each programmer would laboriously write custom code to connect and interact with a service. The availability of more and more services, and particularly the movement toward &lt;a href="https://developers.redhat.com/topics/microservices"&gt;microservices&lt;/a&gt;, created a programming burden.&lt;/p&gt; &lt;p&gt;Integration frameworks such as Camel take this burden off the programmer. The framework makes popular services available to an application through a few lines of code.&lt;/p&gt; &lt;p&gt;In the following sections, we'll examine the technical needs of different eras and the available Camel alternatives that user communities have come up with to meet the demand. &lt;/p&gt; &lt;h2&gt;From traditional integration...&lt;/h2&gt; &lt;p&gt;When Camel was conceived and developed as a Java library, it brought the tools to address and solve enterprise integration patterns (EIPs). Anyone could add Camel in their Java project as a dependency to benefit from its rich functionality.&lt;/p&gt; &lt;p&gt;To deliver enterprise-grade integration, organizations hoped for a complete packaged solution rather than just an added library. Critical functions such as logging, monitoring, a management console, clustering, and support enable a product to become "enterprise-ready."&lt;/p&gt; &lt;div class="pf-l-grid pf-m-gutter"&gt; &lt;div class="pf-l-grid__item pf-m-12-col pf-m-2-col-on-xl pf-m-3-col-on-lg pf-m-3-col-on-sm pf-m-4-col-on-md"&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;img alt="Figure 1: Camel on Karaf." data-entity-type="file" data-entity-uuid="169ff3a4-0eed-4cb9-9cb9-cc2623f5148e" src="https://developers.redhat.com/sites/default/files/inline-images/2022_Apache_Camel__Karaf.png" width="151" height="1413" loading="lazy" /&gt;&lt;figcaption class="rhd-c-caption"&gt;Figure 1: Camel on Karaf.&lt;/figcaption&gt;&lt;/figure&gt;&lt;/div&gt; &lt;div class="pf-l-grid__item pf-m-10-col-on-xl pf-m-12-col pf-m-12-col-on-sm pf-m-8-col-on-md pf-m-9-col-on-lg"&gt; &lt;p&gt;For years, the dominant integration standard was &lt;a href="https://www.osgi.org/"&gt;OSGi&lt;/a&gt;, which originally stood for Open Services Gateway initiative. Apache Karaf implemented OSGi and became a very popular runtime for Camel (Figure 1). Karaf's highly modular architecture allowed programmers to easily and elegantly include all the functional layers mentioned previously (logging, monitoring, etc.). It also encouraged developers to create small Camel projects deployed as independent modules that could easily transition to the emerging microservices approach.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt; &lt;/p&gt; &lt;div class="pf-l-grid pf-m-gutter"&gt; &lt;div class="pf-l-grid__item pf-m-12-col pf-m-2-col-on-xl pf-m-3-col-on-lg pf-m-3-col-on-sm pf-m-4-col-on-md"&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;img alt="Figure 2: Camel on Wildlfy" data-entity-type="file" data-entity-uuid="61331d72-af67-4fc7-b42d-a460c720497f" src="https://developers.redhat.com/sites/default/files/inline-images/2022_Apache_Camel__Wildfly.png" width="151" height="1413" loading="lazy" /&gt;&lt;figcaption class="rhd-c-caption"&gt;Figure 2: Camel on Wildly.&lt;/figcaption&gt;&lt;/figure&gt;&lt;/div&gt; &lt;div class="pf-l-grid__item pf-m-10-col-on-xl pf-m-12-col pf-m-12-col-on-sm pf-m-8-col-on-md pf-m-9-col-on-lg"&gt; &lt;p&gt;Java application servers were also very popular in the enterprise (and still are). Demand soon arose for support to run Camel on top of these servers. &lt;a href="https://www.wildfly.org/"&gt;Wildfly&lt;/a&gt; (better known as JBoss), under the Jave EE specification, also became a Camel runtime choice (Figure 2). Although Wildfly was less suited to running Camel than OSGi, it offered advantages for better integration with Java EE applications.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;h2 id="the_move_to_microservice_architectures-h2"&gt;...to microservice architectures&lt;/h2&gt; &lt;p&gt;The emergence of container environments revolutionized how applications were built, deployed, and managed. Kubernetes soon became the platform of choice, particularly for the more prominent organizations. When the number of integrations is limited, you might still opt to run them in standalone mode, but Kubernetes is seen as the better choice when planning for many services.&lt;/p&gt; &lt;p&gt;In the face of new microservice and distributed architectures running on containers, the popularity of all-in-one solutions—Karaf, Wildfly, and other integration solutions from various vendors (many known as enterprise service buses, or ESBs)—faded away.&lt;/p&gt; &lt;div class="pf-l-grid pf-m-gutter"&gt; &lt;div class="pf-l-grid__item pf-m-12-col pf-m-2-col-on-xl pf-m-3-col-on-lg pf-m-3-col-on-sm pf-m-4-col-on-md"&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;img alt="Figure 3: Camel on Spring Boot." data-entity-type="file" data-entity-uuid="22878ca5-5384-4f46-be34-6892aa23b16c" src="https://developers.redhat.com/sites/default/files/inline-images/2022_Apache_Camel__Springboot.png" width="151" height="1413" loading="lazy" /&gt;&lt;figcaption class="rhd-c-caption"&gt;Figure 3: Camel on Spring Boot.&lt;/figcaption&gt;&lt;/figure&gt;&lt;/div&gt; &lt;div class="pf-l-grid__item pf-m-10-col-on-xl pf-m-12-col pf-m-12-col-on-sm pf-m-8-col-on-md pf-m-9-col-on-lg"&gt; &lt;p&gt;Standalone mode was still viable for running a limited number of integrations. However, Camel and Spring Boot quickly became a very popular combo for developers planning for a large number of services deployed in Kubernetes (Figure 3). Whether running on containers or not, the big microservices movement influenced integration teams to increasingly adopt smaller and more developer-friendly runtimes, and this soon became their preferred approach.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt; &lt;/p&gt; &lt;div class="pf-l-grid pf-m-gutter"&gt; &lt;div class="pf-l-grid__item pf-m-12-col pf-m-2-col-on-xl pf-m-3-col-on-lg pf-m-3-col-on-sm pf-m-4-col-on-md"&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;img alt="Figure 4: Camel on Quarkus." data-entity-type="file" data-entity-uuid="19f01f9b-2e1a-4bb2-b850-68fd7b8fcfdb" src="https://developers.redhat.com/sites/default/files/inline-images/2022_Apache_Camel__Quarkus.png" width="151" height="1414" loading="lazy" /&gt;&lt;figcaption class="rhd-c-caption"&gt;Figure 4: Camel on Quarkus.&lt;/figcaption&gt;&lt;/figure&gt;&lt;/div&gt; &lt;div class="pf-l-grid__item pf-m-10-col-on-xl pf-m-12-col pf-m-12-col-on-sm pf-m-8-col-on-md pf-m-9-col-on-lg"&gt; &lt;p&gt;Fast-forward to the current scene, and you'll find &lt;a href="https://developers.redhat.com/products/quarkus/overview"&gt;Quarkus&lt;/a&gt; playing a pivotal role in ensuring Java's continued relevance (Figure 4). Quarkus saves organizations from investing effort to seek alternatives to Java. Quarkus also allows organizations to retain their codebase and preserves continuity.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;h2&gt;Camel K: A new breed for Kubernetes&lt;/h2&gt; &lt;div class="pf-l-grid pf-m-gutter"&gt; &lt;div class="pf-l-grid__item pf-m-12-col pf-m-2-col-on-xl pf-m-3-col-on-lg pf-m-3-col-on-sm pf-m-4-col-on-md"&gt; &lt;figure class="align-center rhd-u-has-filter-caption" role="group"&gt;&lt;img alt="Figure 5: Camel K." data-entity-type="file" data-entity-uuid="c96666ed-ebf2-4da1-b86a-bfd1b2682e3a" src="https://developers.redhat.com/sites/default/files/inline-images/2022_Apache_Camel__CamelK.png" width="151" height="1413" loading="lazy" /&gt;&lt;figcaption class="rhd-c-caption"&gt;Figure 5: Camel K.&lt;/figcaption&gt;&lt;/figure&gt;&lt;/div&gt; &lt;div class="pf-l-grid__item pf-m-10-col-on-xl pf-m-12-col pf-m-12-col-on-sm pf-m-8-col-on-md pf-m-9-col-on-lg"&gt; &lt;p&gt;To open Apache Camel to a broader audience and lower the entry barrier to run integrations in Kubernetes, &lt;a href="https://developers.redhat.com/topics/camel-k"&gt;Camel K&lt;/a&gt; was conceived (Figure 5). It's a pill to eliminate the headaches of developers running applications in Kubernetes and let them focus on what matters most: the business logic.&lt;/p&gt; &lt;p&gt;All you need to do to run an integration is to define its Camel route, full stop. Camel K is based on Kubernetes &lt;a href="https://operatorframework.io/"&gt;Operators&lt;/a&gt;. As soon as Camel K finds your definition, it builds the integration, creates an image, and deploys it for you. No more time spent solving dependency conflicts—the Operator takes care of that and everything else.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;h3&gt;Kamelets&lt;/h3&gt; &lt;p&gt;Camel K also introduces Kamelets. These are predefined Camel routes (or snippets) you can pick and choose from an out-of-the-box catalog. The key benefit that Kamelets bring to the table is to allow anyone with no previous Camel experience to use them; you just need to configure them. We will dive into Kamelets in more detail in the next installment of this series.&lt;/p&gt; &lt;p&gt;Camel K allows you to bind Kamelets together to connect sources and destinations. You can, for instance, easily configure (declaratively) a data flow from a Java Message Service (JMS) broker to a Kafka platform. Camel K will do the rest: The moment you define your Kamelet binding, the Operator triggers an automatic build and deployment of the integration process that executes your flow definition.&lt;/p&gt; &lt;h2&gt;Current landscape&lt;/h2&gt; &lt;p&gt;The quick timeline in this article helps us understand the many ways to run Camel. In summary, the most popular options are:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;In JVM containers: OSGi, Wildfly&lt;/li&gt; &lt;li&gt;In Java runtimes: Spring Boot&lt;/li&gt; &lt;li&gt;As a native binary: Camel Quarkus&lt;/li&gt; &lt;li&gt;Operator-based: Camel K (powered by Quarkus)&lt;/li&gt; &lt;/ul&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content-full-width"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/camel-choices-knative.gif"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/camel-choices-knative.gif" width="800" height="237" alt="Figure 6. Choosing between various Camel runtimes." loading="lazy" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 6. Choosing between various Camel runtimes. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;h2&gt;Coming up&lt;/h2&gt; &lt;p&gt;This article provided a quick overview of the past, present, and planned future of Apache Camel. I explained how Camel has evolved in response to accelerating changes in markets seeking faster service delivery, increased scale of traffic, and management automation.&lt;/p&gt; &lt;p&gt;&lt;a href="https://developers.redhat.com/articles/2022/03/15/choose-best-camel-your-integration-ride-part-2"&gt;The next installment in the series&lt;/a&gt; will cover both standalone and container environments, show which Camel runtimes fit each, and elaborate on the new paradigms Camel K introduces and the possibilities it unfolds.&lt;/p&gt; &lt;h2 id="learn_more_about_camel_k-h2"&gt;Learn more about Camel Quarkus and Camel K&lt;/h2&gt; &lt;p&gt;See the following resources to learn more about Camel Quarkus and Camel K:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Explore in more detail Camel Quarkus by reading &lt;a href="https://developers.redhat.com/articles/2021/12/06/boost-apache-camel-performance-quarkus"&gt;Boost Apache Camel performance with Quarkus&lt;/a&gt;.&lt;/li&gt; &lt;li&gt;Read the article &lt;a href="https://developers.redhat.com/articles/2021/09/14/improve-cross-team-collaboration-camel-k"&gt;Improve cross-team collaboration with Camel K&lt;/a&gt; to learn about Kamelet bindings and the DSL.&lt;/li&gt; &lt;li&gt;Learn how to implement a complete API integration using &lt;a href="https://developers.redhat.com/articles/2021/11/24/normalize-web-services-camel-k-and-atlasmap-part-1"&gt;Camel K and AtlasMap&lt;/a&gt;.&lt;/li&gt; &lt;li&gt;A good place to start learning about Camel K is the &lt;a href="https://developers.redhat.com/topics/camel-k"&gt;Camel K topic page&lt;/a&gt; on Red Hat Developer.&lt;/li&gt; &lt;li&gt;Visit the &lt;a href="https://developers.redhat.com/products/integration/overview"&gt;Red Hat Integration&lt;/a&gt; page on developers.redhat.com to see complementary capabilities around Camel.&lt;/li&gt; &lt;/ul&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/03/14/choose-best-camel-your-integration-ride-part-1" title="Choose the best Camel for your integration ride, Part 1"&gt;Choose the best Camel for your integration ride, Part 1&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Bruno Meseguer</dc:creator><dc:date>2022-03-14T07:00:00Z</dc:date></entry><entry><title>An easier way to generate PDFs from HTML templates</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/03/11/easier-way-generate-pdfs-html-templates" /><author><name>Muhammad Edwin</name></author><id>7d5e3e90-0a15-4812-9a92-fc9fcd2e2228</id><updated>2022-03-11T07:00:00Z</updated><published>2022-03-11T07:00:00Z</published><summary type="html">&lt;p&gt;Applications frequently are required to generate invoices, reports, ID cards, and much more in PDF format. There are &lt;a href="https://developers.redhat.com/topics/enterprise-java"&gt;Java&lt;/a&gt; libraries and tools that developers can use to generate PDFs, including the popular &lt;a href="https://community.jaspersoft.com/project/jasperreports-library"&gt;JasperReports&lt;/a&gt;. While sophisticated, using these programs can be complicated because they support a wide range of documents.&lt;/p&gt; &lt;p&gt;This article introduces a simpler tool, the open source &lt;a href="https://wkhtmltopdf.org"&gt;wkhtmltopdf&lt;/a&gt; utility. I will show you how to use &lt;code&gt;wkhtmltopdf&lt;/code&gt; to solve a common scenario: You have an HTML form, parameterized to accept input data, and you need to produce a PDF from the data in that form. You will learn how to set up your data and make a call to the &lt;code&gt;wkhtmltopdf&lt;/code&gt; utility from a &lt;a href="https://developers.redhat.com/topics/spring-boot"&gt;Spring Boot&lt;/a&gt; web application. We'll use Red Hat's &lt;a href="https://developers.redhat.com/products/rhel/ubi"&gt;Universal Base Image&lt;/a&gt; (UBI) 8 as a base image to simplify the application build, then deploy the final image into &lt;a href="https://developers.redhat.com/openshift"&gt;Red Hat Openshift&lt;/a&gt; 4.&lt;/p&gt; &lt;p class="Indent1"&gt;&lt;strong&gt;Note:&lt;/strong&gt; You can find the code for the example in my &lt;a href="https://github.com/edwin/spring-boot-and-wkhtmltopdf"&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;Configuration using Maven&lt;/h2&gt; &lt;p&gt;Let's start with a Maven file. I'm using a &lt;a href="https://snowdrop.dev"&gt;Snowdrop&lt;/a&gt; &lt;a href="https://www.baeldung.com/spring-maven-bom"&gt;bill of materials&lt;/a&gt; (BOM) on my Maven project object model (POM) file instead of a community version of Spring Boot:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-xml"&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.edw&lt;/groupId&gt; &lt;artifactId&gt;SpringBootAndPdf&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;redhat-early-access&lt;/id&gt; &lt;name&gt;Red Hat Early Access Repository&lt;/name&gt; &lt;url&gt;https://maven.repository.redhat.com/earlyaccess/all/&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;redhat-ga&lt;/id&gt; &lt;name&gt;Red Hat GA Repository&lt;/name&gt; &lt;url&gt;https://maven.repository.redhat.com/ga/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;redhat-early-access&lt;/id&gt; &lt;name&gt;Red Hat Early Access Repository&lt;/name&gt; &lt;url&gt;https://maven.repository.redhat.com/earlyaccess/all/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;redhat-ga&lt;/id&gt; &lt;name&gt;Red Hat GA Repository&lt;/name&gt; &lt;url&gt;https://maven.repository.redhat.com/ga/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;properties&gt; &lt;snowdrop-bom.version&gt;2.4.9.Final-redhat-00001&lt;/snowdrop-bom.version&gt; &lt;spring-boot.version&gt;2.1.4.RELEASE-redhat-00001&lt;/spring-boot.version&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;dev.snowdrop&lt;/groupId&gt; &lt;artifactId&gt;snowdrop-dependencies&lt;/artifactId&gt; &lt;version&gt;${snowdrop-bom.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;app&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.edw.Main&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt;&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;The Spring Boot program&lt;/h2&gt; &lt;p&gt;Our main class in Java is:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;package com.edw; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class Main { public static void main(String[] args) { SpringApplication.run(Main.class, args); } }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following &lt;code&gt;Controller&lt;/code&gt; class displays a generated PDF. One of the class's most important tasks is to display the PDF properly in a browser; this task is achieved by setting up a proper &lt;code&gt;MediaType&lt;/code&gt; that produces an &lt;code&gt;application/pdf&lt;/code&gt; content-type header. Another important task is to call an external process that runs &lt;code&gt;wkhtmltopdf&lt;/code&gt; to trigger the conversion from HTML to PDF:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;package com.edw.controllers; import org.springframework.http.MediaType; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.Scanner; import java.util.UUID; @Controller public class ReportController { @GetMapping( value = "/generate-report", produces = MediaType.APPLICATION_PDF_VALUE ) public @ResponseBody byte[] generateReport(@RequestParam(value = "name") String name, @RequestParam(value = "address") String address) throws Exception { String uuid = UUID.randomUUID().toString(); Path pathHtml = Paths.get("/tmp/" + uuid + ".html"); Path pathPdf = Paths.get("/tmp/" + uuid + ".pdf"); try { // read the template and fill the data String htmlContent = new Scanner(getClass().getClassLoader().getResourceAsStream("template.html"), "UTF-8") .useDelimiter("\\A") .next(); htmlContent = htmlContent.replace("$name", name) .replace("$address", address); // write to html Files.write(pathHtml, htmlContent.getBytes()); // convert html to pdf Process generateToPdf = Runtime.getRuntime().exec("wkhtmltopdf " + pathHtml.toString() + " " + pathPdf.toString() ); generateToPdf.waitFor(); // deliver pdf return Files.readAllBytes(pathPdf); } finally { // delete temp files Files.delete(pathHtml); Files.delete(pathPdf); } } }&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Formatting the HTML data&lt;/h2&gt; &lt;p&gt;The following HTML template generates a report with input data consisting of names (the &lt;code&gt;$name&lt;/code&gt; parameter) and addresses (the &lt;code&gt;$address&lt;/code&gt; parameter):&lt;/p&gt; &lt;pre&gt; &lt;code class="language-html"&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; &lt;!-- put your css here --&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container" style="padding-top: 100px;"&gt; &lt;div class="row justify-content-center"&gt; &lt;div class="col-md-6"&gt; &lt;table class="table table-bordered"&gt; &lt;thead class="thead-light"&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Address&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;$name&lt;/td&gt; &lt;td&gt;$address&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Installing the wkhtmltopdf program&lt;/h2&gt; &lt;p&gt;This next part is where the magic happens. First, you need to download &lt;code&gt;wkhtmltopdf&lt;/code&gt; from GitHub and extract the program. After that, you can create a &lt;code&gt;wkhtml&lt;/code&gt; folder within your Java project and copy &lt;code&gt;wkhtmltopdf&lt;/code&gt; to the application's folder from the &lt;code&gt;bin&lt;/code&gt; folder:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ wget https://github.com/wkhtmltopdf/wkhtmltopdf/releases/download/0.12.4/wkhtmltox-0.12.4_linux-generic-amd64.tar.xz $ tar -xf wkhtmltox-0.12.4_linux-generic-amd64.tar.xz $ mkdir /code/wkhtml $ cp wkhtmltox/bin/wkhtmltopdf /code/wkhtml/&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The resulting directory structure looks like:&lt;/p&gt; &lt;pre&gt; &lt;code&gt;+--- .gitignore +--- Dockerfile +--- pom.xml +--- src | +--- main | | +--- java | | | +--- com | | | | +--- edw | | | | | +--- controllers | | | | | | +--- HelloWorldController.java | | | | | | +--- ReportController.java | | | | | +--- Main.java | | +--- resources | | | +--- application.properties | | | +--- template.html | +--- test | | +--- java +--- wkhtml | +--- wkhtmltopdf&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Building the image&lt;/h2&gt; &lt;p&gt;The following Dockerfile uses UBI 8 as the base image:&lt;/p&gt; &lt;pre&gt; &lt;code&gt;FROM registry.access.redhat.com/ubi8/openjdk-11-runtime:1.10 USER root ENV LANG='en_US.UTF-8' LANGUAGE='en_US:en' TZ='Asia/Jakarta' RUN microdnf update &amp;&amp; \ microdnf install tzdata libXrender libXext fontconfig &amp;&amp; \ ln -sf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; \ microdnf clean all COPY wkhtml/wkhtmltopdf /usr/local/bin/ EXPOSE 8080 USER 185 COPY target/app.jar /deployments/app.jar ENTRYPOINT [ "java", "-jar", "/deployments/app.jar" ]&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Now, build your image and run it:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ docker build -t springboot-and-pdf . $ docker run -p 8080:8080 springboot-and-pdf&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In your browser, enter the &lt;code&gt;generate-report&lt;/code&gt; URL with a name and address as parameters, and you get a PDF ready to download and print, as shown in Figure 1.&lt;/p&gt; &lt;figure role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/report-pdf.png" data-featherlight="image"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/report-pdf.png?itok=1D-Td2jX" width="600" height="269" alt="The application displays a PDF reflecting the application's HTML template." loading="lazy" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 1. The Spring Boot application generates a PDF report from the data in an HTML template. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;Conclusion&lt;/h2&gt; &lt;p&gt;The streamlined process shown in this example is useful in a variety of situations where you want to generate a report with tabular data or another structured PDF based on input data. Feel free to leave comments on this article to discuss where you might use this approach and any questions you may have.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/03/11/easier-way-generate-pdfs-html-templates" title="An easier way to generate PDFs from HTML templates"&gt;An easier way to generate PDFs from HTML templates&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Muhammad Edwin</dc:creator><dc:date>2022-03-11T07:00:00Z</dc:date></entry><entry><title type="html">This Week in JBoss - 11 March 2022</title><link rel="alternate" href="https://www.jboss.org/posts/weekly-2022-03-11.html" /><category term="quarkus" /><category term="kogito" /><category term="java" /><category term="camel" /><category term="hibernate" /><category term="narayana" /><category term="wildfly" /><category term="cdi-test" /><author><name>Alex Porcelli</name><uri>https://www.jboss.org/people/alex-porcelli</uri><email>do-not-reply@jboss.com</email></author><id>https://www.jboss.org/posts/weekly-2022-03-11.html</id><updated>2022-03-11T00:00:00Z</updated><content type="html">&lt;article class="" data-tags="quarkus, kogito, java, camel, hibernate, narayana, wildfly, cdi-test"&gt; &lt;h1&gt;This Week in JBoss - 11 March 2022&lt;/h1&gt; &lt;p class="preamble"&gt;&lt;/p&gt;&lt;p&gt;Happy Friday, everyone!&lt;/p&gt; &lt;p&gt;Welcome to another edition of the JBoss Editorial that brings you news and updates from your favorite communities.&lt;/p&gt;&lt;p&gt;&lt;/p&gt; &lt;div class="sect1"&gt; &lt;h2 id="_release_roundup"&gt;Release roundup&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;Here are the most recent releases for this edition:&lt;/p&gt; &lt;div class="ulist square"&gt; &lt;ul class="square"&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://quarkus.io/blog/quarkus-2-7-4-final-released/"&gt;Quarkus 2.7.4&lt;/a&gt; maintenance release with a new round of bugfixes and documentation improvements. This should be a safe upgrade upgrade for anyone already using 2.7.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://quarkus.io/blog/intellij-quarkus-tools-1.10.0/"&gt;Quarkus Tools for IntelliJ 1.10.0&lt;/a&gt; release that adds support for Quarkus run/debug configurations and provides several fixes (including security related!).&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://blog.kie.org/2022/03/kogito-1-18-0-released.html"&gt;Kogito 1.18.0&lt;/a&gt; release includes a number of new bug fixes and new features, especially for Serverless Workflows.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://camel.apache.org/blog/2022/03/RELEASE-3.14.2/"&gt;Camel 3.14.2 LTS&lt;/a&gt; new patch release with 27 improvements and fixes.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://in.relation.to/2022/03/09/orm-600-cr2/"&gt;Hibernate ORM 6.0.0.CR2&lt;/a&gt; is expected to be the last release candidate before the 6.0 final release.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://in.relation.to/2022/03/02/hibernate-validator-703-622-final-released/"&gt;Hibernate Validator 6.2.2.Final, 7.0.3.Final and 8.0.0.Alpha1&lt;/a&gt;. Maintenance releases for Hibernate Validator 6.2 and 7.0 branches - both versions bring back support for validating java.sql.Date. The 8.0.0.Alpha1 targets specifically the upcoming Jakarta EE 10.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_testing_jakarta_ee_applications_with_cdi_test"&gt;Testing Jakarta EE applications with CDI-test&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;&lt;a href="http://www.mastertheboss.com/java-ee/jakarta-ee/testing-jakarta-ee-applications-with-cdi-test/"&gt;Testing Jakarta EE applications with CDI-test&lt;/a&gt;, by Gunnar Hilling&lt;/p&gt; &lt;p&gt;In this post, Gunnar presents the CDI-Test JUnit 5 extension, which provides a clever mechanism for unit, component, and integration Jakarta EE application tests at scale.&lt;/p&gt; &lt;p&gt;Gunnar provides a sample repository with a fully functional application and its test so you can use it to follow along with the article.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_narayana_community_priorities"&gt;Narayana Community Priorities&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;&lt;a href="https://jbossts.blogspot.com/2022/03/narayana-community-priorities.html"&gt;Narayana Community Priorities&lt;/a&gt;&lt;/p&gt; &lt;p&gt;This excellent post from Narayana outlines the project’s near-term priorities based on the community’s feedback.&lt;/p&gt; &lt;p&gt;The topics covered by the post include Community Engagement, Java Versions, Integrating with contemporary services, Cloud strategy, and more.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_camel_k_roadmap"&gt;Camel K Roadmap&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;&lt;a href="https://camel.apache.org/blog/2022/03/camel-k-roadmap-2022/"&gt;Camel K Roadmap&lt;/a&gt;, by Pasquale Congiusti&lt;/p&gt; &lt;p&gt;One more great example of what’s planned for the project published in the open! This time Pasquale provides a comprehensive roadmap for the Camel K project for 2022.&lt;/p&gt; &lt;p&gt;Although these plans aren’t commitments, they provide an excellent understanding of where the project is heading.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_wildfly_on_the_cloud_with_helm"&gt;WildFly on the Cloud with Helm&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;&lt;a href="http://www.mastertheboss.com/soa-cloud/openshift/wildfly-on-the-cloud-with-helm/"&gt;WildFly on the Cloud with Helm&lt;/a&gt;, by Francesco Marchioni&lt;/p&gt; &lt;p&gt;The popularity of Helm charts among developers is great. In this article, Francesco provides a step-by-step guide on how to deploy a WildFly application on OpenShift using bootable-jar and source to image.&lt;/p&gt; &lt;p&gt;New to Helm Charts? No worries, Francesco also covers a basic Helm setup.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_editing_serverless_workflow_definitions_with_vscode"&gt;Editing Serverless Workflow Definitions with VSCode&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;&lt;a href="https://blog.kie.org/2022/03/editing-serverless-workflow-definitions-with-our-new-vscode-extension.html"&gt;Editing Serverless Workflow Definitions with our new VSCode Extension&lt;/a&gt;, by Paulo Martins&lt;/p&gt; &lt;p&gt;Here we have Paulo introducing the new VSCode extension for Serverless Workflow provided by Red Hat, which allows users to have a side-by-side real-time preview of their workflows while editing JSON and YAML files inside VSCode.&lt;/p&gt; &lt;p&gt;Serverless Workflow is a CNCF based specification for workflows that Kogito already supports; check this out!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_content_based_routing_with_quarkus_and_kogito"&gt;Content based routing with Quarkus and Kogito&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;&lt;a href="https://blog.kie.org/2022/03/content-based-routing-with-quarkus-and-kogito.html"&gt;Content based routing with Quarkus and Kogito&lt;/a&gt;, by Matteo Mortari&lt;/p&gt; &lt;p&gt;One more post about the Kogito technology! This time we have Matteo presenting a content-based router using DMN, Quarkus, Kogito, Camel, Atlas Map, Managed Kafka, and OpenShift Sandbox! Ohh my!&lt;/p&gt; &lt;p&gt;The post is very detailed, covering content with code examples and, more interesting, a link for a youtube video where Matteo explains the concepts and shows a live demo!&lt;/p&gt; &lt;p&gt;&lt;em&gt;That’s all for today! Please join us again in two weeks for another round of our JBoss editorial!&lt;/em&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="author"&gt; &lt;pfe-avatar pfe-shape="circle" pfe-pattern="squares" pfe-src="/img/people/alex-porcelli.png"&gt;&lt;/pfe-avatar&gt; &lt;span&gt;Alex Porcelli&lt;/span&gt; &lt;/div&gt;&lt;/article&gt;</content><dc:creator>Alex Porcelli</dc:creator></entry><entry><title type="html">Testing Jakarta EE applications with CDI-test</title><link rel="alternate" href="http://www.mastertheboss.com/java-ee/jakarta-ee/testing-jakarta-ee-applications-with-cdi-test/" /><author><name>Gunnar Hilling</name></author><id>http://www.mastertheboss.com/java-ee/jakarta-ee/testing-jakarta-ee-applications-with-cdi-test/</id><updated>2022-03-10T09:25:02Z</updated><content type="html">This article introduces the Testing framework CDI-Test which you can use to test JakartaEE and Microprofile applications at scale. CDI Test: why you need it First of all: We all love developing in the Java EE ecosystem. Or at least we do since version 5… Or maybe we don’t but our employers do. Partly because ... The post appeared first on .</content><dc:creator>Gunnar Hilling</dc:creator></entry></feed>
